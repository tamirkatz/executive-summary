from langchain_core.messages import AIMessage
from typing import Dict, List, Any

from ..classes import ResearchState


class Collector:
    """Collects and organizes queries generated by the query generation agent."""

    async def collect(self, state: ResearchState) -> ResearchState:
        """Collect and verify queries generated by the query generation agent."""
        company = state.get('company', 'Unknown Company')
        msg = [f"📦 Collecting generated queries for {company}:"]

        if websocket_manager := state.get('websocket_manager'):
            if job_id := state.get('job_id'):
                await websocket_manager.send_status_update(
                    job_id=job_id,
                    status="processing",
                    message=f"Collecting generated queries for {company}",
                    result={"step": "Collecting Queries"}
                )
        
        # Collect generated queries from query_generation_agent
        generated_queries: List[str] = state.get('generated_queries', [])
        query_generation_complete: bool = state.get('query_generation_complete', False)
        
        if query_generation_complete and generated_queries:
            msg.append(f"✅ Query Generation Complete: {len(generated_queries)} queries collected")
            
            # Categorize queries for better organization
            categorized_queries = self._categorize_queries(generated_queries)
            
            # Update state with categorized queries
            state['categorized_queries'] = categorized_queries
            state['total_queries'] = len(generated_queries)
            state['query_collection_complete'] = True
            
            # Log query categories
            for category, queries in categorized_queries.items():
                if queries:
                    msg.append(f"• {category}: {len(queries)} queries")
        else:
            msg.append("⚠️ No queries found from query generation agent")
            state['categorized_queries'] = {}
            state['total_queries'] = 0
            state['query_collection_complete'] = False
        
        # Update state with collection message
        messages = state.get('messages', [])
        messages.append(AIMessage(content="\n".join(msg)))
        state['messages'] = messages
        
        return state

    def _categorize_queries(self, queries: List[str]) -> Dict[str, List[str]]:
        """Categorize queries based on their content and keywords."""
        categories = {
            'financial': [],
            'news': [],
            'company': [],
            'technology': [],
            'market': [],
            'competitor': [],
            'partnership': [],
            'regulatory': [],
            'geopolitical': [],
            'risk': [],
            'opportunity': [],
            'general': []
        }
        
        for query in queries:
            query_lower = query.lower()
            
            # Financial queries
            if any(keyword in query_lower for keyword in [
                'financial', 'funding', 'revenue', 'valuation', 'investor', 
                'ipo', 'profitability', 'cash flow', 'financial performance',
                'funding rounds', 'investors', 'financial metrics', 'burn rate',
                'unit economics', 'customer acquisition cost', 'lifetime value'
            ]):
                categories['financial'].append(query)
            
            # News queries
            elif any(keyword in query_lower for keyword in [
                'news', 'announcement', 'press release', 'media coverage', 'recent',
                'latest', 'breaking', 'update', 'development', 'launch'
            ]):
                categories['news'].append(query)
            
            # Company queries
            elif any(keyword in query_lower for keyword in [
                'company', 'business model', 'leadership', 'team', 'overview',
                'mission', 'vision', 'strategy', 'history', 'milestones'
            ]):
                categories['company'].append(query)
            
            # Technology queries
            elif any(keyword in query_lower for keyword in [
                'technology', 'ai', 'digital', 'software', 'cloud', 'data',
                'automation', 'cybersecurity', 'api', 'machine learning',
                'blockchain', 'iot', 'edge computing', 'quantum computing'
            ]):
                categories['technology'].append(query)
            
            # Market queries
            elif any(keyword in query_lower for keyword in [
                'market', 'industry', 'growth', 'trends', 'opportunities',
                'market size', 'market share', 'customer behavior', 'forecast'
            ]):
                categories['market'].append(query)
            
            # Competitor queries
            elif any(keyword in query_lower for keyword in [
                'competitor', 'competition', 'vs', 'comparison', 'competitive'
            ]):
                categories['competitor'].append(query)
            
            # Partnership queries
            elif any(keyword in query_lower for keyword in [
                'partnership', 'alliance', 'collaboration', 'joint venture',
                'integration', 'ecosystem', 'network'
            ]):
                categories['partnership'].append(query)
            
            # Regulatory queries
            elif any(keyword in query_lower for keyword in [
                'regulatory', 'compliance', 'legal', 'regulations', 'gdpr',
                'privacy', 'standards', 'approval'
            ]):
                categories['regulatory'].append(query)
            
            # Geopolitical queries
            elif any(keyword in query_lower for keyword in [
                'international', 'global', 'trade', 'geopolitical', 'cross-border',
                'foreign', 'international expansion'
            ]):
                categories['geopolitical'].append(query)
            
            # Risk queries
            elif any(keyword in query_lower for keyword in [
                'risk', 'threat', 'vulnerability', 'challenge', 'obstacle'
            ]):
                categories['risk'].append(query)
            
            # Opportunity queries
            elif any(keyword in query_lower for keyword in [
                'opportunity', 'potential', 'growth', 'expansion', 'innovation'
            ]):
                categories['opportunity'].append(query)
            
            # General queries (catch-all)
            else:
                categories['general'].append(query)
        
        # Remove empty categories
        return {k: v for k, v in categories.items() if v}

    async def run(self, state: ResearchState) -> ResearchState:
        return await self.collect(state)